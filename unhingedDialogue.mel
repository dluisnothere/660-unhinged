global proc string stringArrayToString(string $array[], string $separator)
{
    string $result = "";
    for ($elem in $array) {
        if ($result == "") {
            $result = $elem;
        } else {
            $result = $result + $separator + $elem;
        }
    }
    return $result;
}

global int $foldNodeId = 0;

global proc int genFoldNode()
{        
    global int $foldNodeId;
    string $selected[] = `ls -sl`;
    print($selected);
    
    string $patches = stringArrayToString($selected, ", ");
    
    if (size($selected)) {
        int $sizeSel = size($selected);
        print($sizeSel);
        
        string $instanceName = "instancer" + $foldNodeId;
        instancer -n $instanceName;
    
        string $nodeName = "foldableNode" + $foldNodeId;
        createNode foldableNode -n $nodeName;
        
        setAttr ($nodeName + ".patchList") -type "string" $patches;
        setAttr -lock true ($nodeName + ".patchList");
        
        print("Node name: ");
        print($nodeName);
        print("Instancer Name: ");
        print($instanceName);
        
        // string $nodeInTime = $nodeName + ".inTime";
        string $nodeOutPoints = $nodeName + ".outPoint";
        string $instanceInPoints = $instanceName + ".inputPoints";
        
        // connectAttr time1.outTime $nodeInTime; 
        connectAttr $nodeOutPoints $instanceInPoints;
        
        $foldNodeId++;
    } else {
        print("nothing selected");
    }
    return true;
}

global proc updatePivotToMidpoint(string $polyPlane) {
    // Get the world-space positions of the vertices of the first edge (edge 0)
    vector $vtx0 = `xform -q -ws -t ($polyPlane + ".vtx[1]")`;
    vector $vtx1 = `xform -q -ws -t ($polyPlane + ".vtx[3]")`;

    // Calculate the midpoint of the edge
    vector $midpoint = ($vtx0 + $vtx1) / 2;

    // Set the rotate pivot to the calculated midpoint
    xform -ws -rp ($midpoint.x) ($midpoint.y) ($midpoint.z) $polyPlane;
}

global proc onNameChanged(string $oldName, string $newName) {
    // Update the scriptJob to use the new name of the object
    scriptJob -e AttributeChange ($newName + ".scale") ("updatePivotToMidpoint(\"" + $newName + "\");") -replacePrevious true;
}

global proc createScaleMonitor(string $polyPlane) {
    // Define the command string for the scriptJob, using placeholders for the polyPlane name
    string $commandString = "updatePivotToMidpoint(\"#POLYPLANE#\");";
    
    // Substitute the placeholder with the actual polyPlane name
    $commandString = `substituteAllString $commandString "#POLYPLANE#" $polyPlane`;

    // Create a scriptJob to monitor the scale attribute of the polyplane
    int $jobID = `scriptJob -attributeChange ($polyPlane + ".scale") $commandString`;
    
    // scriptJob -e nameChanged ($polyPlane) "onNameChanged";

    // Print the scriptJob ID
    // print ("Created scriptJob with ID: " + $jobID + "\n");
}

// Call the createScaleMonitor function with the name of your polyplane

global int $planeID = 0;


global proc int genFoldPatch()
{
    // Access the global variable for the ID increment
    global int $planeID;
    
    // Create the PolyPlane with size 1x1 and only one subdivision
    string $polyPlane[] = `polyPlane -w 1 -h 1 -sx 1 -sy 1`;
    
    // Rename the PolyPlane with the incremented ID
    string $newName = "plane_" + $planeID;
    $polyPlaneCurr = `rename $polyPlane[0] $newName`;
    
    // Make the displayScalePivot and displayRotatePivot visible
    string $displayRotatePivot = $newName + ".displayRotatePivot";
    setAttr ($displayRotatePivot) 1;
    
    // Move the rotate pivot to the local position (0.5, 0, 0) in world space
    //string $rotatePivotAttr = $newName + ".rotatePivot";
    //setAttr ($rotatePivotAttr + "X") 0.5;
    //setAttr ($rotatePivotAttr + "Y") 0;
    //setAttr ($rotatePivotAttr + "Z") 0;
    xform -os -rp 0.5 0.0 0.0 $newName;

    // Increment the global ID
    $planeID++;
    
    // Translate back to the origin
    setAttr ($newName + ".translateX") -0.5;
    // rotate -r 0 0 -90 $polyPlaneCurr;
    setAttr ($newName + ".translateY") -0.5;
    
    // Make this the new origin
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -pn 1;
    
    setAttr ($newName + ".translateY") 0.5;
    rotate -r 0 0 -90 $polyPlaneCurr;
    
    createScaleMonitor($polyPlaneCurr);
    
    return true;
}

global proc int genBasePatch()
{
    // Access the global variable for the ID increment
    global int $planeID;
    
    // Create the PolyPlane with size 1x1 and only one subdivision
    string $polyPlane[] = `polyPlane -w 1 -h 1 -sx 1 -sy 1`;
    
    // Rename the PolyPlane with the incremented ID
    string $newName = "plane_" + $planeID;
    $polyPlaneCurr = `rename $polyPlane[0] $newName`;

    // Make the displayScalePivot and displayRotatePivot visible
    string $displayRotatePivot = $newName + ".displayRotatePivot";
    setAttr ($displayRotatePivot) 1;

    // Increment the global ID
    $planeID++;
    
    return true;
}

global proc int densifyGrid(int $size)
{
    grid -d $size -sp 1;
    return true;
}

global proc int onCheckboxChange(int $checked) 
{
    if ($checked) {
        snapMode -grid on -dsi 0.1;
    } else {
        snapMode -grid off;
    }
    return true;
}

global proc int genMenu()
{
    window -title "Unhinged Plugin: Di Lu and David Li CIS 660";
    	columnLayout -w 500;
    		button -label "Create Fold Patch" -command "genFoldPatch";
    		button -label "Create Base Patch" -command "genBasePatch";
    	    button -label "Create Foldable Node" -command "genFoldNode";
    	    // button -label "Densify Grid" -command "densifyGrid";
    	    intSliderGrp -label "Grid Density" -field true -fieldMinValue 1 -fieldMaxValue 20 -minValue 1 -maxValue 20 -value 1
    	           -changeCommand "densifyGrid #1"; 
            checkBox -label "Snap to Grid" -changeCommand "onCheckboxChange #1" snapCheckbox;
    	setParent ..;
    showWindow;
    return true;

}

{
    if(`menu -exists FoldableMenu`)
    {
        deleteUI FoldableMenu;
    }
}

{   
    global string $gMainWindow;
    string $lsystemMenu = `menu -p $gMainWindow -label "Unhinged" FoldableMenu`;
    menuItem -label "Open" -command "genMenu" genMenuItem;
    // menuItem -label "Create" -command "genFoldNode" MyMenuItem;
}
